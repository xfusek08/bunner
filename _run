#!/bin/bash

_run_in_bun() {
    
}

error() {
    echo -e "\033[1;31m❌ $1\033[0m"
}

info() {
    echo -e "\033[1;34mℹ️ $1\033[0m"
}

die() {
    error "$1"
    exit 1
}

boolval() {
    local value="$1"
    if [ -z "$value" ]; then
        echo "false"
    else
        echo "true"
    fi
}

source ./scripts/print_csv.sh

is_not_null () { [[ "$1" != "null" ]] }

filter_array() {
    local -n input_array=$1  # Reference to input array
    local fn=$2
    local result=()
    
    for ((i=0; i<${#input_array[@]}; i++)); do
        if $fn "${input_array[$i]}" "$i"; then
            result+=("${input_array[$i]}")
        fi
    done
    echo "${result[@]}"
}

# Array-based map
map_array() {
    local -n input_array=$1  # Reference to input array
    local fn=$2
    local result=()
    
    for ((i=0; i<${#input_array[@]}; i++)); do
        result+=("$($fn "${input_array[$i]}" "$i")")
    done
    echo "${result[@]}"
}

_runner_process_options() {
    local description="$1"; shift
    local -n option_defs=$1; shift
    local -n pos_args=$1; shift
    local -n active_opts=$1; shift
    
    # Prepare arguments for getopt
    local short_opts=()
    local long_opts=()
    local default_values=()
    local descriptions=()
    local cnt=0
    
    # Add implicit options
    option_defs["h|help"]="Show help message"
    option_defs["|description"]="Show description"
    
    for key in "${!option_defs[@]}"; do
        
        # key is in format s|silent[|default_value]
        short_opts[$cnt]=$(echo "$key" | cut -d'|' -f1)
        long_opts[$cnt]=$(echo "$key" | cut -d'|' -f2)
        default_values[$cnt]=$(echo "$key" | cut -d'|' -f3)
        descriptions[$cnt]="${option_defs[$key]}"
        
        local hasShort=$(boolval "${short_opts[$cnt]}")
        local hasLong=$(boolval "${long_opts[$cnt]}")
        local hasDefault=$(boolval "${default_values[$cnt]}")
        local hasDescription=$(boolval "${descriptions[$cnt]}")
        
        # Check if option definition is valid
        if [ $hasShort == "false" ] && [ $hasLong == "false" ]; then
            die "Option definition must have at least one short or long option"
        fi
        
        if [ $hasShort == "false" ]; then
            short_opts[$cnt]="null"
        fi
        
        if [ $hasLong == "false" ]; then
            long_opts[$cnt]="null"
        fi
        
        # Default value
        if [ $hasDefault == "false" ]; then
            default_values[$cnt]="null"
        fi
        
        # Description
        if [ $hasDescription == "false" ]; then
            descriptions[$cnt]="No description available"
        fi
        
        cnt=$((cnt + 1))
    done
    
    echo "Short opts: ${short_opts[*]}"
    echo "Long opts: ${long_opts[*]}"
    echo "Default values: ${default_values[*]}"
    echo "Descriptions: ${descriptions[*]}"
    
    function _generate_help() {
        echo -e "\033[1m$description\033[0m"
        echo ""
        echo -e "\033[1mOptions:\033[0m"
        
        for ((i=0; i<$option_count; i++)); do
            local short="${short_opts[$i]}"
        done
        
        echo ""
    }
    
    if [ $cnt -gt 0 ]; then
    
        local short_processed=$(filter_array short_opts is_not_null)
        short_processed=$(map_array a process_option)
        info "short_opts: ${short_opts[@]}"
        die "Short processed: ${short_processed[@]}"
        
        IFS=""
        local short_joined="${short_opts[*]}"
        IFS=","
        local long_joined="${long_opts[*]}"
        
        echo "-o \"${short_joined}\" --long \"${long_joined}\" -n $0 -- $@"
        local parsed_options=$(getopt -o "${short_joined}" --long "${long_joined}" -n "$0" -- "$@")
        eval set -- "$parsed_options"
        while true  ; do
            echo "processing option: \"$1\""
            case "$1" in
                -h|--help)
                    _generate_help
                    exit 0
                    ;;
                --description)
                    echo -e "\033[1m$description\033[0m"
                    exit 0
                    ;;
                --)
                    shift
                    break
                    ;;
                *)
                    echo "ERROR: Invalid option $1" >&2
                    return 1
                    ;;
            esac
        done
    fi
    
    
    
    return 4
}

_runner_display_running_containers() {
    # <service_name>
    #   - <container_id> <container_name>
    #   - <container_id> <container_name>
    # <service_name>
    #   - <container_id> <container_name>
    #  ...
    docker compose ps --services | while read -r service_name; do
        echo "$service_name"
        docker compose ps --filter "Name=${service_name}" --format "table {{.ID}}\t{{.Names}}" | tail -n +2 | while read -r container_info; do
            echo "  - $container_info"
        done
    done
}

# Task functions with built-in help
_runner_task_up() {
    
    declare -A in_option_definitions=(
        ["s|silent"]="Run silently without output"
        ["c|color|white"]="Color of the output"
    )
    declare -A out_active_options=()
    declare -a out_positional_arguments=()
    
    _runner_process_options "Executes docker compose up" \
        in_option_definitions \
        out_positional_arguments \
        out_active_options \
        "$@"
    
    local ret=$?
    if [ $ret -eq 4 ]; then
        return 0
    elif [ $ret -ne 0 ]; then
        return $ret
    fi
    
    if ! command -v docker >/dev/null 2>&1; then
        die "Docker is not installed or not in PATH"
    fi
    
    if ! docker compose up -d "${out_positional_arguments[@]}"; then
        die "Failed to start containers"
    fi
    
    if [ "${out_active_options[s]:-false}" != "true" ]; then
        _runner_display_running_containers
    fi
    
    return 0
}

# Task functions with built-in help
_runner_task_down() {
    
    declare -A in_option_definitions=()
    declare -A out_active_options=()
    declare -a out_positional_arguments=()
    
    _runner_process_options "Executes docker compose down" \
        in_option_definitions \
        out_positional_arguments \
        out_active_options \
        "$@"
    
    local ret=$?
    if [ $ret -eq 4 ]; then
        return 0
    elif [ $ret -ne 0 ]; then
        return $ret
    fi
    
    if ! command -v docker >/dev/null 2>&1; then
        die "Docker is not installed or not in PATH"
    fi
    
    if ! docker compose down "${out_positional_arguments[@]}"; then
        die "Failed to stop containers"
    fi
}

_runner_task_help() {
    echo -e "\033[1mUsage:\033[0m $0 [command] [command options]"
    echo ""
    echo -e "\033[1mAvailable commands:\033[0m"
    
    local commands=$(declare -F | grep "^declare -f _runner_task_" | sed 's/declare -f _runner_task_//')
    
    local csv=""
    while read -r command; do
        if [ "$command" == "help" ]; then
            continue
        fi
        local description=$("_runner_task_$command" --description 2>/dev/null)
        description="${description:-"No description available"}"
        csv="${csv}    ${command};${description}\n"
    done <<< "$commands"
    
    echo -e "$csv" | print_csv --colors "34"
    echo ""
    echo -e "Use '\033[1m$0 <command> -h\033[0m' for more information about a command"
}

# Main execution logic
main() {
    local cmd="$1"
    if [ -z "$cmd" ]; then
        _runner_task_help
        exit 1
    fi

    if ! type "_runner_task_$cmd" &>/dev/null; then
        error "Unknown command: $cmd"
        _runner_task_help
        exit 1
    fi

    shift
    "_runner_task_$cmd" "$@"
    exit $?
}

main "$@"
